1
00:00:02,680 --> 00:00:08,910
ここでは、文字列の補間を詳しく見て、コンポーネントを提供していきましょう。

2
00:00:09,100 --> 00:00:14,770
今年は、このような年齢層であなたの成果を望んでいません。私はここで成果をハードコードしたくありません。

3
00:00:14,770 --> 00:00:15,770
&nbsp;

4
00:00:15,900 --> 00:00:22,020
サーバーコンポーネントには特定のサーバーに関する情報が含まれていることが現実的です。

5
00:00:22,330 --> 00:00:34,450
テンプレートファイルで、IDを持つサーバと、次にオフラインのようなステータスの下にあるいくつかの動的IDを出力したいと思うかもしれません。

6
00:00:34,840 --> 00:00:37,020
&nbsp;

7
00:00:37,210 --> 00:00:39,820
ここには2つの動的フィールドがあります。

8
00:00:40,370 --> 00:00:46,360
さて、HGPのバックエンドや計算の要求から導き出されるかもしれない実際のアプリケーションで、それらのタイプコードとタイプスクリプトコードを導出するのは意味があります。

9
00:00:46,360 --> 00:00:52,050
&nbsp;

10
00:00:52,090 --> 00:00:54,560
今のところそれはここでハードコードされます。

11
00:00:54,820 --> 00:01:01,300
だから私たちはサーバIDを持っているかもしれません。私は10のletの値を割り当てます。

12
00:01:01,330 --> 00:01:11,320
だから、数字と私はまた、文字列と数字の2つの異なるタイプので、行の文字列である固定子にサーバーを持っています。

13
00:01:11,380 --> 00:01:13,210
&nbsp;

14
00:01:13,570 --> 00:01:19,920
また、必要ではありませんが、プロパティ名の後にコロンを追加し、自動的に終了するタイプを追加するというスクリプトタイプの型を割り当てることによって、非常に明示的にすることもできます。

15
00:01:20,140 --> 00:01:25,500
&nbsp;

16
00:01:25,490 --> 00:01:29,710
それらは必要ではありません私はデモ目的のためにこれをここでやっています。

17
00:01:30,100 --> 00:01:37,020
だから今私のテンプレートでこれらの2つのプロパティを出力し、この接続を得るためには、データ型マイニングが必要です。

18
00:01:37,030 --> 00:01:42,020
&nbsp;

19
00:01:42,370 --> 00:01:49,750
ですから、stringinの苦難は通常、プレースホルダの代わりにこのタスクの典型的な解決策を使用します。

20
00:01:50,170 --> 00:01:51,220
&nbsp;

21
00:01:51,280 --> 00:01:58,050
私は二重中括弧を使用しています。これは文字列の補間構文を行います。これらの二重中括弧の間には、typescript式を書くことができます。

22
00:01:58,170 --> 00:02:04,440
&nbsp;

23
00:02:04,810 --> 00:02:12,670
したがって、最も簡単な表現は、単にサーバーIDのようなプロパティーを参照することです。これは、ここでプロパティーまたはプロパティーの値のみを出力する一般的な使用例です。

24
00:02:12,670 --> 00:02:19,340
&nbsp;

25
00:02:19,360 --> 00:02:22,630
しかし、唯一のユースケースではありません。

26
00:02:22,630 --> 00:02:30,790
例えば、サーバーの場合は年を指定するだけで、最後に文字列に解決できる任意の式を文字列にハードコードすることもできます。

27
00:02:30,790 --> 00:02:33,190
&nbsp;

28
00:02:33,190 --> 00:02:37,910
これは、ここで欠乏の文字列のための唯一の条件です。

29
00:02:37,940 --> 00:02:43,640
だから、最後に中括弧の間にあるものは何とか文字列を返す必要があります。

30
00:02:43,720 --> 00:02:50,530
だから、最後に文字列を返すメソッドをここで呼び出すことができます。ここでは、ここでは複数行の式を書くことができます。

31
00:02:50,710 --> 00:02:52,910
&nbsp;

32
00:02:52,960 --> 00:03:00,410
ここにブロック式を書くことはできないので、あなたのif構造体のif構造体やfor構造体を追加することはできません。

33
00:03:00,550 --> 00:03:03,120
あなたは三元表現を使用することができます。

34
00:03:03,490 --> 00:03:06,230
これはあなたができることです。

35
00:03:06,250 --> 00:03:12,400
ここで最後のプレースホルダを置き換えてみましょう。ここでも、サーバーの状態をプロパティで参照します。

36
00:03:12,400 --> 00:03:14,250
&nbsp;

37
00:03:14,260 --> 00:03:20,280
今これはあなたの検索の文字列の照合であり、文字列そのものである式があることがわかります。

38
00:03:20,280 --> 00:03:21,240
&nbsp;

39
00:03:21,430 --> 00:03:25,090
そして、単にプロパティを指す2つのAbregoの抑圧。

40
00:03:25,150 --> 00:03:28,690
また、ここでも文字列を返すメソッドを呼び出すことができます。

41
00:03:28,690 --> 00:03:30,270
今興味深い。

42
00:03:30,270 --> 00:03:33,720
サーバーIDは文字列ではなく数値です。

43
00:03:33,760 --> 00:03:41,200
そして、私はちょうど歓声の文字列が文字列に解決しなければならないと言って、最後は文字列を最後につける必要があります。

44
00:03:41,200 --> 00:03:41,930
&nbsp;

45
00:03:42,070 --> 00:03:46,800
だから、もしこれを保存してもまだ動作していれば、これが動作するかどうかを見てみましょう。

46
00:03:46,960 --> 00:03:52,170
また、オブザーバーをオブザーバーに戻して、この作業をやり直してみましょう。

47
00:03:52,240 --> 00:03:58,420
ID

48
00:03:58,420 --> 00:04:04,600
10のサーバーはオフラインですが、各コンポーネントでこのコンポーネントを繰り返しているため、2回表示されていますが、コンテンツは同じですが、ストレイン・トライブレーションが機能していることがわかりました。

49
00:04:05,080 --> 00:04:09,130
&nbsp;

50
00:04:09,160 --> 00:04:16,090
だから私は数字が簡単に文字列に変換できるので、正常に動作している10のデータは問題ではありませんでした。

51
00:04:16,090 --> 00:04:17,130
&nbsp;

52
00:04:17,140 --> 00:04:24,190
だから、最後に文字列を取得するか、文字列に変換して実際に正しいものにする必要があります。

53
00:04:24,190 --> 00:04:25,810
&nbsp;

54
00:04:25,870 --> 00:04:28,230
これは、文字列の不足を使用する方法です。

55
00:04:28,450 --> 00:04:35,620
そして、実際にこの例を実際に完成させるために、ここでサーバの状態が何とかMeffertで返されるとしましょう。サーバの状態はメソッド名になります。

56
00:04:35,770 --> 00:04:38,970
&nbsp;

57
00:04:39,010 --> 00:04:41,680
これは、typescriptでメソッドを定義する方法です。

58
00:04:41,680 --> 00:04:45,730
だからあなたは私たちの言葉からMathaの定義を知るかもしれません。

59
00:04:45,940 --> 00:04:51,430
そして、ここでは、このサーバーの状態を返すだけです。

60
00:04:51,520 --> 00:04:58,180
したがって、私たちはプロパティを返すか、もちろん、すでに行ったように直接アクセスすることができますが、メソッドを呼び出すことができることを実証します。

61
00:04:58,210 --> 00:05:00,500
&nbsp;

62
00:05:00,610 --> 00:05:08,140
&nbsp;

63
00:05:08,140 --> 00:05:14,470
&nbsp;

64
00:05:14,470 --> 00:05:17,050
ここでは、メソッドの呼び出しは、サービスのステータスを取得すると同じ出力につながります。この計算では、最後に文字列として返されるか、文字列に変換できない文字列が返されるためです。
